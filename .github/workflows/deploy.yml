name: Deploy OXS CLI

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOTNET_VERSION: '10.0.x'
  PROJECT_PATH: 'src/simplic-oxs-cli/oxs.csproj'
  OUTPUT_NAME: 'oxs'

jobs:
  build-linux:
    name: Build and Package Linux x64
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Get version from project
      id: version
      shell: bash
      run: |
        # Extract version from csproj or use timestamp-based version
        if grep -q "<Version>" ${{ env.PROJECT_PATH }}; then
          VERSION=$(grep "<Version>" ${{ env.PROJECT_PATH }} | sed 's/.*<Version>\(.*\)<\/Version>.*/\1/')
        else
          # Generate version from commit date and short SHA
          VERSION="1.0.$(date +'%Y%m%d').$(git rev-parse --short HEAD)"
        fi
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Build project
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore

    - name: Publish Linux x64
      shell: bash
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} \
          --configuration Release \
          --runtime linux-x64 \
          --self-contained true \
          --output ./src/publish/linux-x64 \
          -p:PublishSingleFile=true \
          -p:Version=${{ steps.version.outputs.VERSION }}

    - name: Create Linux package
      shell: bash
      run: |
        cd ./src/publish/linux-x64
        
        # Create install script for Linux
        cat > install.sh << 'EOF'
        #!/bin/bash
        # OXS CLI Linux Installer

        INSTALL_DIR="$HOME/.local/bin"
        EXECUTABLE_NAME="oxs"

        echo "Installing OXS CLI..."

        # Create installation directory
        mkdir -p "$INSTALL_DIR"

        # Copy executable
        cp "$EXECUTABLE_NAME" "$INSTALL_DIR/$EXECUTABLE_NAME"
        chmod +x "$INSTALL_DIR/$EXECUTABLE_NAME"

        # Add to PATH in shell profiles if not already present
        for profile in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
            if [[ -f "$profile" ]]; then
                if ! grep -q "$INSTALL_DIR" "$profile"; then
                    echo "export PATH=\"$PATH:$INSTALL_DIR\"" >> "$profile"
                    echo "Added $INSTALL_DIR to PATH in $profile"
                fi
            fi
        done

        echo "Installation completed successfully!"
        echo "Please restart your terminal or run: source ~/.bashrc (or your shell's profile)"
        echo "You can then use the 'oxs' command from any location"
        EOF

        chmod +x install.sh

        # Create README for Linux package
        cat > README.md << 'EOF'
        # OXS CLI - Linux Package

        ## Installation

        ### Option 1: Quick Install (Recommended)
        ```bash
        chmod +x install.sh
        ./install.sh
        ```

        ### Option 2: Manual Install
        1. Copy `oxs` to a directory in your PATH (e.g., `/usr/local/bin` or `~/.local/bin`)
        2. Make it executable: `chmod +x oxs`

        ## Usage
        After installation, you can use the `oxs` command from any location in your terminal.
        EOF
        
        # Place zip at repository root
        zip -r ../../../oxs-linux-x64-v${{ steps.version.outputs.VERSION }}.zip .

    - name: Upload Linux artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-artifacts
        path: |
          oxs-linux-x64-v${{ steps.version.outputs.VERSION }}.zip
    
  build-windows:
    name: Build, Sign and Package Windows x64
    runs-on: windows-latest
    needs: build-linux
    permissions:
      contents: write
    env:
      CODE_SIGN_PFX: ${{ secrets.CODE_SIGN_PFX }}
      CODE_SIGN_PFX_PASSWORD: ${{ secrets.CODE_SIGN_PFX_PASSWORD }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Get version from project
      id: version
      shell: bash
      run: |
        if grep -q "<Version>" ${{ env.PROJECT_PATH }}; then
          VERSION=$(grep "<Version>" ${{ env.PROJECT_PATH }} | sed 's/.*<Version>\(.*\)<\/Version>.*/\1/')
        else
          VERSION="1.0.$(date +'%Y%m%d').$(git rev-parse --short HEAD)"
        fi
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Build project
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore

    - name: Publish Windows x64
      shell: bash
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} \
          --configuration Release \
          --runtime win-x64 \
          --self-contained true \
          --output ./src/publish/win-x64 \
          -p:PublishSingleFile=true \
          -p:Version=${{ steps.version.outputs.VERSION }}

    - name: Prepare code signing certificate
      if: ${{ env.CODE_SIGN_PFX != '' && env.CODE_SIGN_PFX_PASSWORD != '' }}
      shell: pwsh
      run: |
        $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
        [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODE_SIGN_PFX))
        Write-Host "PFX written to $pfxPath"

    - name: Import certificate to CurrentUser store
      id: import_certificate
      if: ${{ env.CODE_SIGN_PFX != '' && env.CODE_SIGN_PFX_PASSWORD != '' }}
      shell: pwsh
      run: |
        $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
        $password = $env:CODE_SIGN_PFX_PASSWORD
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString -String $password -AsPlainText -Force)
        if (-not $cert) { throw "Failed to import certificate" }
        Write-Host "Imported cert thumbprint: $($cert.Thumbprint)"
        echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_OUTPUT

    - name: Sign Windows executable
      if: ${{ env.CODE_SIGN_PFX != '' && env.CODE_SIGN_PFX_PASSWORD != '' }}
      shell: pwsh
      run: |
        $exe = "${{ github.workspace}}\src\publish\win-x64\oxs.exe"
        $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
        # Locate signtool.exe
        $signTool = Get-Command signtool.exe -ErrorAction SilentlyContinue
        if (-not $signTool) {
          $signTool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "\\x64\\" } |
            Sort-Object FullName -Descending |
            Select-Object -First 1
        }
        if (-not $signTool) { throw "signtool.exe not found on runner" }
        $signToolPath = if ($signTool -is [System.Management.Automation.CommandInfo]) { $signTool.Source } else { $signTool.FullName }
        & "$signToolPath" sign /f "$pfxPath" /p "$env:CODE_SIGN_PFX_PASSWORD" /tr "http://timestamp.digicert.com" /td SHA256 /fd SHA256 /v "$exe"
        # Verify signature; if using a self-signed certificate, verification may fail due to untrusted root.
        # Do not fail the pipeline in that case; emit a warning and continue.
        & "$signToolPath" verify /pa /v "$exe"
        if ($LASTEXITCODE -ne 0) {
          Write-Warning "Signature verification failed (possibly due to self-signed certificate). Continuing without failing the job."
          $global:LASTEXITCODE = 0
        }

    - name: Create Windows installer script
      shell: bash
      run: |
        mkdir -p ./src/publish/windows-installer
        cat > ./src/publish/windows-installer/install.ps1 << 'EOF'
        # OXS CLI Windows Installer
        param(
            [string]$InstallPath = "$env:LOCALAPPDATA\Programs\OXS-CLI"
        )

        Write-Host "Installing OXS CLI..." -ForegroundColor Green

        # Create installation directory
        if (!(Test-Path $InstallPath)) {
            New-Item -ItemType Directory -Path $InstallPath -Force | Out-Null
        }

        # Copy executable
        $exePath = Join-Path $InstallPath "oxs.exe"
        Copy-Item "oxs.exe" $exePath -Force

        # Add to PATH if not already present
        $currentPath = [Environment]::GetEnvironmentVariable("Path", "User")
        if ($currentPath -notlike "*$InstallPath*") {
            $newPath = if ($currentPath) { "$currentPath;$InstallPath" } else { $InstallPath }
            [Environment]::SetEnvironmentVariable("Path", $newPath, "User")
            Write-Host "Added $InstallPath to user PATH" -ForegroundColor Green
        }

        # Create uninstaller
        $uninstallerPath = Join-Path $InstallPath "uninstall.ps1"
        @"
        # OXS CLI Uninstaller
        Write-Host "Uninstalling OXS CLI..." -ForegroundColor Yellow
        Remove-Item "$InstallPath" -Recurse -Force -ErrorAction SilentlyContinue
        
        # Remove from PATH
        `$currentPath = [Environment]::GetEnvironmentVariable("Path", "User")
        `$newPath = (`$currentPath -split ";") | Where-Object { `$_ -ne "$InstallPath" }
        [Environment]::SetEnvironmentVariable("Path", (`$newPath -join ";"), "User")
        
        Write-Host "OXS CLI uninstalled successfully" -ForegroundColor Green
        "@ | Out-File $uninstallerPath -Encoding UTF8

        Write-Host "Installation completed successfully!" -ForegroundColor Green
        Write-Host "You can now use 'oxs' command from any location (restart your terminal)" -ForegroundColor Cyan
        Write-Host "To uninstall, run: powershell -ExecutionPolicy Bypass -File `"$uninstallerPath`"" -ForegroundColor Gray
        EOF

    - name: Create Windows package
      shell: bash
      run: |
        cd ./src/publish/win-x64
        cp ../windows-installer/install.ps1 .
        
        # Create README for Windows package
        cat > README.md << 'EOF'
        # OXS CLI - Windows Package

        ## Installation

        ### Option 1: Quick Install (Recommended)
        Run the following command in PowerShell (as Administrator):
        ```powershell
        powershell -ExecutionPolicy Bypass -File .\install.ps1
        ```

        ### Option 2: Manual Install
        1. Copy `oxs.exe` to a directory of your choice
        2. Add that directory to your PATH environment variable

        ## Usage
        After installation, you can use the `oxs` command from any location in your terminal.

        ## Uninstallation
        If you used the installer, you can uninstall by running the uninstall script created during installation.
        EOF
        
        # Place zip at repository root
        powershell -Command "Compress-Archive -Path * -DestinationPath ../../../oxs-windows-x64-v${{ steps.version.outputs.VERSION }}.zip"
    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-artifacts
        path: |
          oxs-windows-x64-v${{ steps.version.outputs.VERSION }}.zip

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-linux, build-windows]
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Download Linux artifact
      uses: actions/download-artifact@v4
      with:
        name: linux-artifacts
        path: ./dist
    - name: Download Windows artifacts
      uses: actions/download-artifact@v4
      with:
        name: windows-artifacts
        path: ./dist
    - name: Get version from project
      id: version
      shell: bash
      run: |
        if grep -q "<Version>" ${{ env.PROJECT_PATH }}; then
          VERSION=$(grep "<Version>" ${{ env.PROJECT_PATH }} | sed 's/.*<Version>\(.*\)<\/Version>.*/\1/')
        else
          VERSION="1.0.$(date +'%Y%m%d').$(git rev-parse --short HEAD)"
        fi
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Extract release notes
      id: release_notes
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.VERSION }}"
        
        # Function to extract content for a specific version
        extract_version_content() {
          local version="$1"
          local file="RELEASENOTES.md"
          
          if [ ! -f "$file" ]; then
            echo "RELEASENOTES.md not found"
            return 1
          fi
          
          # Look for the version header (e.g., "# 1.0.2")
          local start_line=$(grep -n "^# $version" "$file" | head -1 | cut -d: -f1)
          
          if [ -z "$start_line" ]; then
            echo "Version $version not found in RELEASENOTES.md"
            return 1
          fi
          
          # Find the next version header or end of file
          local next_version_line=$(tail -n +$((start_line + 1)) "$file" | grep -n "^# " | head -1 | cut -d: -f1)
          
          if [ -n "$next_version_line" ]; then
            # Extract content between this version and next version
            local end_line=$((start_line + next_version_line - 1))
            sed -n "${start_line},${end_line}p" "$file" | tail -n +2 | head -n -1
          else
            # Extract from this version to end of file
            tail -n +$((start_line + 1)) "$file"
          fi
        }
        
        # Try to get release notes for the current version
        WHATS_NEW=$(extract_version_content "$VERSION")
        
        if [ -z "$WHATS_NEW" ] || [ "$WHATS_NEW" = "Version $VERSION not found in RELEASENOTES.md" ]; then
          # Fallback content if version not found in RELEASENOTES.md
          WHATS_NEW="- Built with .NET 10
      - Self-contained executables (no .NET runtime required)
      - Automatic PATH registration
      - Easy uninstallation scripts included"
        fi
        
        # Save to output, handling multiline content
        {
          echo 'WHATS_NEW<<EOF'
          echo "$WHATS_NEW"
          echo 'EOF'
        } >> $GITHUB_OUTPUT

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ steps.version.outputs.VERSION }}
        name: Release v${{ steps.version.outputs.VERSION }}
        body: |
          ## OXS CLI Release v${{ steps.version.outputs.VERSION }}
          
          ### Download Options
          
          **Windows Users:**
          - ? [Windows x64 Package](https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.VERSION }}/oxs-windows-x64-v${{ steps.version.outputs.VERSION }}.zip) - Includes installer script
          
          **Linux Users:**
          - ? [Linux x64 Package](https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.VERSION }}/oxs-linux-x64-v${{ steps.version.outputs.VERSION }}.zip) - Includes installer script
          
          ### Installation Instructions
          
          #### Windows (Recommended)
          1. Download the Windows x64 package
          2. Extract the zip file
          3. Run `install.ps1` in PowerShell as Administrator:
             ```powershell
             powershell -ExecutionPolicy Bypass -File .\install.ps1
             ```
          4. Restart your terminal and use `oxs` command
          
          #### Linux
          1. Download the Linux x64 package
          2. Extract the zip file
          3. Run the installer:
             ```bash
             chmod +x install.sh
             ./install.sh
             ```
          4. Restart your terminal and use `oxs` command
          
          ### What's New
          ${{ steps.release_notes.outputs.WHATS_NEW }}
          
          ---
          *Built from commit ${{ github.sha }}*
        files: |
          ./dist/oxs-windows-x64-v${{ steps.version.outputs.VERSION }}.zip
          ./dist/oxs-linux-x64-v${{ steps.version.outputs.VERSION }}.zip
        draft: false
        prerelease: false





